/*테스트를 해보기위해 임의로 스토어를 초기화할때 shape의 초기화는 쉽지 않아 store구조체에서 shape는 주석처리하고 진행하였습니다*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "prototype.h"
#include <windows.h>
#include <conio.h>

typedef struct Node //노드 개별을 의미
{
	Store* store;
	struct Node* before;
	struct Node* after;
}Node;

typedef struct list //리스트 
{
	Node* head;
	Node* tail;
}List;

void list_init(List* target)
{
	target->head = NULL;
	target->tail = NULL;
}
void add_first(List* target, Store* store) //tail은 고정 head는 계속 새로운 노드로 갱신 
{
	Node* newNode = (Node*)malloc(sizeof(Node));
	newNode->store = store;

	if (target->head == NULL) { //노드가 비어있음
		target->tail = newNode;
		target->tail->after = newNode;
		target->tail->before = newNode;
		newNode->after = target->tail;
		newNode->before = target->tail;
		target->head = newNode;
		return;
	}
	
	if (target->head != NULL) 
	{
		newNode->before = target->head->before;
		target->tail->after = newNode;
		newNode->after = target->head;
		target->head->before = newNode;
		target->head = newNode;
		return;
	}
}

void push_back(List* target, Store* store) //head는 고정 tail이 계속 newNode를 가리키게됨
{
	Node* newNode = (Node*)malloc(sizeof(Node));
	Node* cur = target->tail;

	if (target->head == NULL)
	{
		add_first(target, store);
		return;
	}
	newNode->after = target->tail->after;
	newNode->before = target->head->before;
	target->head->before = newNode;
	target->tail->after = newNode;
	target->tail = newNode;
	newNode->store = store;
}

int delete(List* target, int id)
{
	Node* temp = NULL;
	Node* cur = target->head;

	//노드가 존재하지 않을 때
	if (target->head == NULL)
	{
		return -1;
	}
	else {

		//head를 지울 때
		if (cur->store->id == id) {
			target->head = target->head->after;
			cur->before->after = cur->after;
			cur->after->before = cur->before;
			free(cur);
			return 0;
		}
		else {
			cur = cur->after;

			while (cur != target->head) {
				if (cur->store->id == id) {
					//tail를 지울 때
					if (cur == target->tail) {
						target->tail = target->tail->before;
						cur->before->after = cur->after;
						cur->after->before = cur->before;
						free(cur);
						return 0;
					}
					cur->before->after = cur->after;
					cur->after->before = cur->before;
					free(cur);
					return 0;
				}
				else {
					cur = cur->after;
				}
			}
			return 1;
		}
	}
}

void check(int bool) {
	if (bool == 0) {
		printf("가게와의 계약을 취소했습니다.\n");
	}
	else if(bool == -1) {
		printf(가게가 존재하지 않습니다\n");
	}
	else {
		printf("해당 아이디를 가진 가게가 존재하지 않습니다\n");
	}
}

void find(List* target, int level) 
{

	Node* cur = target->head;

	if (target->head == NULL)
	{
		printf("가게가 존재하지 않습니다\n");
	}
	else {

		if (cur->store->level == level) {
			printf("가게이름: %s \n    수입: %d\n  임대료: %d\n    재산: %d\n", cur->store->name, cur->store->income, cur->store->rent, cur->store->money);
		}
		cur = cur->after;
		while (cur != target->head)
		{
			if (cur->store->level == level) {
				printf("가게이름: %s \n    수입: %d\n  임대료: %d\n    재산: %d\n", cur->store->name, cur->store->income, cur->store->rent, cur->store->money);
			}
			cur = cur->after;
		}
	}
}

void rfind(List* target, int level)
{
	Node* cur = target->tail;

	if (target->head == NULL)
	{
		printf("가게가 존재하지 않습니다\n");
	}
	else {

		if (cur->store->level == level)
			if (cur->store->level == level) {
				printf("가게이름: %s \n    수입: %d\n  임대료: %d\n    재산: %d\n", cur->store->name, cur->store->income, cur->store->rent, cur->store->money);
			}
		cur = cur->before;
		while (cur != target->tail)
		{
			if (cur->store->level == level) {
				printf("가게이름: %s \n    수입: %d\n  임대료: %d\n    재산: %d\n", cur->store->name, cur->store->income, cur->store->rent, cur->store->money);
			}
			cur = cur->before;
		}
	}
}

void findOne(List* target, int level) { //방향키 한번 누를때마다 한개씩 보여주는 함수
	int ch; 
	int input = 77; //오른쪽 방향키 아스키코드

	Node* cur = target->head;

	while (1) {
		if (target->head == NULL)
		{
			printf("가게가 존재하지 않습니다\n");
		}
		else {
			if (_kbhit()) {
				ch = _getch();
				if (ch == input) {
					if (cur->store->level == level) {
						system("cls");
						printf("가게이름: %s \n    수입: %d\n  임대료: %d\n    재산: %d\n", cur->store->name, cur->store->income, cur->store->rent, cur->store->money);
						cur = cur->after;
					}
					while (cur->store->level != level) {
						cur =cur->after;
					}
					continue;
				}
			}
		}
	}
}

void rfindOne(List* target, int level) { //방향키 한번 누를때마다 한개씩 보여주는 함수
	int ch;
	int input = 75; //왼쪽 방향키 아스키코드

	Node* cur = target->tail;

	while (1) {
		if (target->head == NULL)
		{
			printf("가게가 존재하지 않습니다\n");
		}
		else {
			if (_kbhit()) {
				ch = _getch();
				if (ch == input) {
					if (cur->store->level == level) {
						system("cls");
						printf("가게이름: %s \n    수입: %d\n  임대료: %d\n    재산: %d\n", cur->store->name, cur->store->income, cur->store->rent, cur->store->money);
						cur = cur->before;
					}
					while (cur->store->level != level) {
						cur = cur->before;
					}
					continue;
				}
			}
		}
	}
}


int main() {
	
	List list;

	list_init(&list);

/*테스트를 해보기위해 임의로 스토어를 초기화할때 shape의 초기화는 쉽지 않아 store구조체에서 shape는 주석처리하고 진행하였습니다*/
	Store store1 = { "세탁소", 100, 50, 400 ,1, 2 };
	Store store2 = { "주차장", 100 ,50, 400, 2, 1 }; //Store store2 = { "주차장", 100 ,50, 400, 2, 2 }; //한 개씩 볼때 예외처리 되었는지 확인
	Store store3 = { "이발소", 100, 50, 400, 3, 2 };
	Store store4 = { "피시방", 100, 50, 400, 4, 1 }; //Store store4 = { "피시방", 100, 50, 400, 4, 2 };
	Store store5 = { "백반집", 100, 50, 400, 5, 2 };

	push_back(&list, &store1);
	push_back(&list, &store2);
	push_back(&list, &store3);
	push_back(&list, &store4);
	push_back(&list, &store5);


	/*find(&list, 2);
	printf("\n");
	check(delete(&list, 5));
	printf("\n");
	find(&list, 2);
	printf("\n");
	rfind(&list,2);
    */

	/*find(&list, 2);
	printf("\n");
	rfind(&list, 2);*/


	
	/*findOne(&list, 2)*/
	rfindOne(&list, 2);
}
